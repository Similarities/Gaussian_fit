warning: LF will be replaced by CRLF in divergence_single_gaussian_fit.py.
The file will have its original line endings in your working directory
[1mdiff --cc divergence_single_gaussian_fit.py[m
[1mindex 780763a,1b5542e..0000000[m
[1m--- a/divergence_single_gaussian_fit.py[m
[1m+++ b/divergence_single_gaussian_fit.py[m
[36m@@@ -1,141 -1,141 +1,285 @@@[m
[31m -#!/usr/bin/env python2[m
[31m -# -*- coding: utf-8 -*-[m
[31m -"""[m
[31m -Created on Tue Feb 19 16:54:54 2019[m
[31m -[m
[31m -@author: similarities[m
[31m -"""[m
[31m -[m
[31m -import matplotlib.pyplot as plt[m
[31m -import numpy as np[m
[31m -import random[m
[31m -import math[m
[31m -[m
[31m -from lmfit.models import GaussianModel[m
[31m -[m
[31m -[m
[31m -class FWHM_Gaussian_Fit_Processing:[m
[31m -[m
[31m -    def __init__(self, filename, lambda_fundamental, pixel_range, harmonic_selected, filedescription):[m
[31m -        self.filename = filename[m
[31m -        self.ymin = 0[m
[31m -        self.ymax = 2048[m
[31m -        self.xmin = 0[m
[31m -        self.xmax = 2048[m
[31m -        self.pixel_range = pixel_range[m
[31m -        self.picture = np.empty([])[m
[31m -        self.x_backsubstracted = np.empty([2048, 2048])[m
[31m -        self.lambda_fundamental = lambda_fundamental[m
[31m -        self.full_divergence = 17.5[m
[31m -        spatial_detector_calibration = self.full_divergence / 2048[m
[31m -        self.lineout_x = np.arange(self.xmin, self.xmax) * spatial_detector_calibration - self.full_divergence / 2[m
[31m -        self.lineout_y = np.zeros([2048, 1])[m
[31m -        self.filedescription = filedescription[m
[31m -        self.harmonic_selected = harmonic_selected[m
[31m -        self.sigma_temp = float[m
[31m -        self.amplitude_temp = float[m
[31m -        self.center_temp = float[m
[31m -        self.px_boarder = 0[m
[31m -        self.selected_harmonic_in_px()[m
[31m -[m
[31m -    def open_file(self):[m
[31m -        self.picture = plt.imread(self.filename)[m
[31m -        return self.picture[m
[31m -[m
[31m -    def background(self):[m
[31m -        back_mean = np.mean(self.picture[:, 1780:1948], axis=1)[m
[31m -        for x in range(0, self.ymax):[m
[31m -            self.x_backsubstracted[::, x] = self.picture[::, x] - back_mean[x][m
[31m -        plt.figure(1)[m
[31m -        plt.imshow(self.x_backsubstracted)[m
[31m -        return self.x_backsubstracted[m
[31m -[m
[31m -    def grating_function(self):[m
[31m -        x_axis_in_nm = np.empty([2048, 1])[m
[31m -        for x in range(0, self.ymax):[m
[31m -            x_axis_in_nm[x] = 1.24679344e-06 * x ** 2 - 1.65566701e-02 * x + 5.22598053e+01[m
[31m -        return x_axis_in_nm[m
[31m -[m
[31m -    def selected_harmonic_in_px(self):[m
[31m -        harmonic_in_nm = self.lambda_fundamental / self.harmonic_selected[m
[31m -        # this function should be inverse of the grating function[m
[31m -        self.px_boarder = (4.71439193e-01 * harmonic_in_nm ** 2 - 1.06651902e+02 * harmonic_in_nm + 4.29603367e+03)[m
[31m -        print(self.px_boarder, "selected N in px")[m
[31m -        return self.px_boarder[m
[31m -[m
[31m -    def create_sub_array_px_range(self):[m
[31m -        border_up = int(self.px_boarder - self.pixel_range / 2)[m
[31m -        border_down = int(self.px_boarder + self.pixel_range / 2)[m
[31m -        plt.figure(1)[m
[31m -        plt.hlines(border_up, xmin=0, xmax=2048, color="m", linewidth=0.5)[m
[31m -        plt.hlines(border_down, xmin=0, xmax=2048, color="w", linewidth=1.)[m
[31m -        return self.x_backsubstracted[border_up: border_down, ::][m
[31m -[m
[31m -    def check_fundamental(self):[m
[31m -        sub_array = self.create_sub_array_px_range()[m
[31m -        line_out_y = sub_array[::,1200][m
[31m -        print(line_out_y)[m
[31m -        line_out_y_1 = list(range(0,self.pixel_range))[m
[31m -        print(line_out_y_1)[m
[31m -        self.plot_x_y(line_out_y_1, line_out_y, 'lineout_over_harmonic_y', 'px', 'counts', 4)[m
[31m -        maximum_in_y = np.where(np.amax(sub_array[::, 1200]))[m
[31m -        print('maximum px position: {0} in px-range {1}'.format(maximum_in_y, self.pixel_range))[m
[31m -[m
[31m -    def sum_over_pixel_range(self):[m
[31m -        self.lineout_y = np.sum(self.create_sub_array_px_range(), axis=0)[m
[31m -        return self.lineout_y[m
[31m -[m
[31m -    def set_to_zero_offest(self):[m
[31m -        self.lineout_y[::] = self.lineout_y[::] - np.amin(self.lineout_y[150:1900])[m
[31m -        return self.lineout_y[m
[31m -[m
[31m -    def fit_gaussian(self):[m
[31m -        self.set_to_zero_offest()[m
[31m -        mod = GaussianModel()[m
[31m -        pars = mod.guess(self.lineout_y, x=self.lineout_x)[m
[31m -        out = mod.fit(self.lineout_y, pars, x=self.lineout_x)[m
[31m -        print(out.fit_report(min_correl=0.15))[m
[31m -        self.sigma_temp = out.params['sigma'].value[m
[31m -        self.amplitude_temp = out.params['amplitude'].value[m
[31m -        self.center_temp = out.params['center'].value[m
[31m -        print('sigma: {0} for N:{1} = {2:8.2f}nm'[m
[31m -              .format(self.sigma_temp, self.harmonic_selected, self.lambda_fundamental / self.harmonic_selected))[m
[31m -[m
[31m -        return self.sigma_temp, self.amplitude_temp, self.center_temp[m
[31m -[m
[31m -    def plot_x_y(self, x, y, name, x_label, y_label, plot_number):[m
[31m -        plt.figure(plot_number)[m
[31m -        plt.plot(x, y, label=name)[m
[31m -        plt.xlabel('x_label')[m
[31m -        plt.ylabel('y_label')[m
[31m -        plt.legend()[m
[31m -[m
[31m -    def plot_fit_function(self):[m
[31m -        xx = np.linspace(-self.full_divergence / 2, self.full_divergence, 1000)[m
[31m -        yy = np.zeros([len(xx), 1])[m
[31m -        for x in range(0, len(xx)):[m
[31m -            yy[x] = (self.amplitude_temp / (self.sigma_temp * ((2 * math.pi) ** 0.5))) * math.exp([m
[31m -                (-(xx[x] - self.center_temp) ** 2) / (2 * self.sigma_temp ** 2))[m
[31m -[m
[31m -        self.plot_x_y(self.lineout_x, self.lineout_y, self.filedescription, 'mrad', 'counts', 2)[m
[31m -        self.plot_x_y(xx, yy, 'fit_function', 'mrad', 'counts', 2)[m
[31m -[m
[31m -    def save_linout(self):[m
[31m -        hey = np.stack((self.lineout_x * self.spatial_detector_calibration, self.lineout_y), axis=1)[m
[31m -        np.savetxt(self.filedescription + "lineout" + ".txt", hey, delimiter=' ', fmt='%1.4e')[m
[31m -[m
[31m -[m
[31m -# insert the following ('filepath/picture_name.tif', fundamental frequency (float), ROI_y(px), harmonic number (int), "picture name for plot")[m
[31m -[m
[31m -Picture1 = FWHM_Gaussian_Fit_Processing('rotated/spectro1__Wed Jan 23 2019_14.51.31_17.tif', 805., 60, 23, "20190123_17")[m
[31m -Picture1.open_file()[m
[31m -Picture1.background()[m
[31m -Picture1.check_fundamental()[m
[31m -[m
[31m -Picture1.sum_over_pixel_range()[m
[31m -[m
[31m -Picture1.fit_gaussian()[m
[31m -Picture1.plot_fit_function()[m
[31m -# Picture1.save_data()[m
[31m -[m
[31m -plt.show()[m
[32m++<<<<<<< HEAD[m
[32m +#!/usr/bin/env python2[m
[32m +# -*- coding: utf-8 -*-[m
[32m +"""[m
[32m +Created on Tue Feb 19 16:54:54 2019[m
[32m +[m
[32m +@author: similarities[m
[32m +"""[m
[32m +[m
[32m +import matplotlib.pyplot as plt[m
[32m +import numpy as np[m
[32m +import random[m
[32m +import math[m
[32m +[m
[32m +from lmfit.models import GaussianModel[m
[32m +[m
[32m +[m
[32m +class FWHM_Gaussian_Fit_Processing:[m
[32m +[m
[32m +    def __init__(self, filename, lambda_fundamental, pixel_range, harmonic_selected, filedescription):[m
[32m +        self.filename = filename[m
[32m +        self.ymin = 0[m
[32m +        self.ymax = 2048[m
[32m +        self.xmin = 0[m
[32m +        self.xmax = 2048[m
[32m +        self.pixel_range = pixel_range[m
[32m +        self.picture = np.empty([])[m
[32m +        self.x_backsubstracted = np.empty([2048, 2048])[m
[32m +        self.lambda_fundamental = lambda_fundamental[m
[32m +        self.full_divergence = 17.5[m
[32m +        spatial_detector_calibration = self.full_divergence / 2048[m
[32m +        self.lineout_x = np.arange(self.xmin, self.xmax) * spatial_detector_calibration - self.full_divergence / 2[m
[32m +        self.lineout_y = np.zeros([2048, 1])[m
[32m +        self.filedescription = filedescription[m
[32m +        self.harmonic_selected = harmonic_selected[m
[32m +        self.sigma_temp = float[m
[32m +        self.amplitude_temp = float[m
[32m +        self.center_temp = float[m
[32m +        self.px_boarder = 0[m
[32m +        self.selected_harmonic_in_px()[m
[32m +[m
[32m +    def open_file(self):[m
[32m +        self.picture = plt.imread(self.filename)[m
[32m +        return self.picture[m
[32m +[m
[32m +    def background(self):[m
[32m +        back_mean = np.mean(self.picture[:, 1780:1948], axis=1)[m
[32m +        for x in range(0, self.ymax):[m
[32m +            self.x_backsubstracted[::, x] = self.picture[::, x] - back_mean[x][m
[32m +        plt.figure(1)[m
[32m +        plt.imshow(self.x_backsubstracted)[m
[32m +        return self.x_backsubstracted[m
[32m +[m
[32m +    def grating_function(self):[m
[32m +        x_axis_in_nm = np.empty([2048, 1])[m
[32m +        for x in range(0, self.ymax):[m
[32m +            x_axis_in_nm[x] = 1.24679344e-06 * x ** 2 - 1.65566701e-02 * x + 5.22598053e+01[m
[32m +        return x_axis_in_nm[m
[32m +[m
[32m +    def selected_harmonic_in_px(self):[m
[32m +        harmonic_in_nm = self.lambda_fundamental / self.harmonic_selected[m
[32m +        # this function should be inverse of the grating function[m
[32m +        self.px_boarder = (4.71439193e-01 * harmonic_in_nm ** 2 - 1.06651902e+02 * harmonic_in_nm + 4.29603367e+03)[m
[32m +        print(self.px_boarder, "selected N in px")[m
[32m +        return self.px_boarder[m
[32m +[m
[32m +    def create_sub_array_px_range(self):[m
[32m +        border_up = int(self.px_boarder - self.pixel_range / 2)[m
[32m +        border_down = int(self.px_boarder + self.pixel_range / 2)[m
[32m +        plt.figure(1)[m
[32m +        plt.hlines(border_up, xmin=0, xmax=2048, color="m", linewidth=0.5)[m
[32m +        plt.hlines(border_down, xmin=0, xmax=2048, color="w", linewidth=1.)[m
[32m +        return self.x_backsubstracted[border_up: border_down, ::][m
[32m +[m
[32m +    def check_fundamental(self):[m
[32m +        sub_array = self.create_sub_array_px_range()[m
[32m +        line_out_y = sub_array[::,1200][m
[32m +        print(line_out_y)[m
[32m +        line_out_y_1 = list(range(0,self.pixel_range))[m
[32m +        print(line_out_y_1)[m
[32m +        self.plot_x_y(line_out_y_1, line_out_y, 'lineout_over_harmonic_y', 'px', 'counts', 4)[m
[32m +        maximum_in_y = np.where(np.amax(sub_array[::, 1200]))[m
[32m +        print('maximum px position: {0} in px-range {1}'.format(maximum_in_y, self.pixel_range))[m
[32m +[m
[32m +    def sum_over_pixel_range(self):[m
[32m +        self.lineout_y = np.sum(self.create_sub_array_px_range(), axis=0)[m
[32m +        return self.lineout_y[m
[32m +[m
[32m +    def set_to_zero_offest(self):[m
[32m +        self.lineout_y[::] = self.lineout_y[::] - np.amin(self.lineout_y[150:1900])[m
[32m +        return self.lineout_y[m
[32m +[m
[32m +    def fit_gaussian(self):[m
[32m +        self.set_to_zero_offest()[m
[32m +        mod = GaussianModel()[m
[32m +        pars = mod.guess(self.lineout_y, x=self.lineout_x)[m
[32m +        out = mod.fit(self.lineout_y, pars, x=self.lineout_x)[m
[32m +        print(out.fit_report(min_correl=0.15))[m
[32m +        self.sigma_temp = out.params['sigma'].value[m
[32m +        self.amplitude_temp = out.params['amplitude'].value[m
[32m +        self.center_temp = out.params['center'].value[m
[32m +        print('sigma: {0} for N:{1} = {2:8.2f}nm'[m
[32m +              .format(self.sigma_temp, self.harmonic_selected, self.lambda_fundamental / self.harmonic_selected))[m
[32m +[m
[32m +        return self.sigma_temp, self.amplitude_temp, self.center_temp[m
[32m +[m
[32m +    def plot_x_y(self, x, y, name, x_label, y_label, plot_number):[m
[32m +        plt.figure(plot_number)[m
[32m +        plt.plot(x, y, label=name)[m
[32m +        plt.xlabel('x_label')[m
[32m +        plt.ylabel('y_label')[m
[32m +        plt.legend()[m
[32m +[m
[32m +    def plot_fit_function(self):[m
[32m +        xx = np.linspace(-self.full_divergence / 2, self.full_divergence, 1000)[m
[32m +        yy = np.zeros([len(xx), 1])[m
[32m +        for x in range(0, len(xx)):[m
[32m +            yy[x] = (self.amplitude_temp / (self.sigma_temp * ((2 * math.pi) ** 0.5))) * math.exp([m
[32m +                (-(xx[x] - self.center_temp) ** 2) / (2 * self.sigma_temp ** 2))[m
[32m +[m
[32m +        self.plot_x_y(self.lineout_x, self.lineout_y, self.filedescription, 'mrad', 'counts', 2)[m
[32m +        self.plot_x_y(xx, yy, 'fit_function', 'mrad', 'counts', 2)[m
[32m +[m
[32m +    def save_linout(self):[m
[32m +        hey = np.stack((self.lineout_x * self.spatial_detector_calibration, self.lineout_y), axis=1)[m
[32m +        np.savetxt(self.filedescription + "lineout" + ".txt", hey, delimiter=' ', fmt='%1.4e')[m
[32m +[m
[32m +[m
[32m +# insert the following ('filepath/picture_name.tif', fundamental frequency (float), ROI_y(px), harmonic number (int), "picture name for plot")[m
[32m +[m
[32m +Picture1 = FWHM_Gaussian_Fit_Processing('rotated/spectro1__Wed Jan 23 2019_14.51.31_17.tif', 805., 60, 23, "20190123_17")[m
[32m +Picture1.open_file()[m
[32m +Picture1.background()[m
[32m +Picture1.check_fundamental()[m
[32m +[m
[32m +Picture1.sum_over_pixel_range()[m
[32m +[m
[32m +Picture1.fit_gaussian()[m
[32m +Picture1.plot_fit_function()[m
[32m +# Picture1.save_data()[m
[32m +[m
[32m +plt.show()[m
[32m++=======[m
[32m++#!/usr/bin/env python2[m
[32m++# -*- coding: utf-8 -*-[m
[32m++"""[m
[32m++Created on Tue Feb 19 16:54:54 2019[m
[32m++[m
[32m++@author: similarities[m
[32m++"""[m
[32m++[m
[32m++import matplotlib.pyplot as plt[m
[32m++import numpy as np[m
[32m++import random[m
[32m++import math[m
[32m++[m
[32m++from lmfit.models import GaussianModel[m
[32m++[m
[32m++[m
[32m++class FWHM_Gaussian_Fit_Processing:[m
[32m++[m
[32m++    def __init__(self, filename, lambda_fundamental, pixel_range, harmonic_selected, filedescription):[m
[32m++        self.filename = filename[m
[32m++        self.ymin = 0[m
[32m++        self.ymax = 2048[m
[32m++        self.xmin = 0[m
[32m++        self.xmax = 2048[m
[32m++        self.pixel_range = pixel_range[m
[32m++        self.picture = np.empty([])[m
[32m++        self.x_backsubstracted = np.empty([2048, 2048])[m
[32m++        self.lambda_fundamental = lambda_fundamental[m
[32m++        self.full_divergence = 17.5[m
[32m++        spatial_detector_calibration = self.full_divergence / 2048[m
[32m++        self.lineout_x = np.arange(self.xmin, self.xmax) * spatial_detector_calibration - self.full_divergence / 2[m
[32m++        self.lineout_y = np.zeros([2048, 1])[m
[32m++        self.filedescription = filedescription[m
[32m++        self.harmonic_selected = harmonic_selected[m
[32m++        self.sigma_temp = float[m
[32m++        self.amplitude_temp = float[m
[32m++        self.center_temp = float[m
[32m++        self.px_boarder = 0[m
[32m++        self.selected_harmonic_in_px()[m
[32m++[m
[32m++    def open_file(self):[m
[32m++        self.picture = plt.imread(self.filename)[m
[32m++        return self.picture[m
[32m++[m
[32m++    def background(self):[m
[32m++        back_mean = np.mean(self.picture[:, 1780:1948], axis=1)[m
[32m++        for x in range(0, self.ymax):[m
[32m++            self.x_backsubstracted[::, x] = self.picture[::, x] - back_mean[x][m
[32m++        plt.figure(1)[m
[32m++        plt.imshow(self.x_backsubstracted)[m
[32m++        return self.x_backsubstracted[m
[32m++[m
[32m++    def grating_function(self):[m
[32m++        x_axis_in_nm = np.empty([2048, 1])[m
[32m++        for x in range(0, self.ymax):[m
[32m++            x_axis_in_nm[x] = 1.24679344e-06 * x ** 2 - 1.65566701e-02 * x + 5.22598053e+01[m
[32m++        return x_axis_in_nm[m
[32m++[m
[32m++    def selected_harmonic_in_px(self):[m
[32m++        harmonic_in_nm = self.lambda_fundamental / self.harmonic_selected[m
[32m++        # this function should be inverse of the grating function[m
[32m++        self.px_boarder = (4.71439193e-01 * harmonic_in_nm ** 2 - 1.06651902e+02 * harmonic_in_nm + 4.29603367e+03)[m
[32m++        print(self.px_boarder, "selected N in px")[m
[32m++        return self.px_boarder[m
[32m++[m
[32m++    def create_sub_array_px_range(self):[m
[32m++        border_up = int(self.px_boarder - self.pixel_range / 2)[m
[32m++        border_down = int(self.px_boarder + self.pixel_range / 2)[m
[32m++        plt.figure(1)[m
[32m++        plt.hlines(border_up, xmin=0, xmax=2048, color="m", linewidth=0.5)[m
[32m++        plt.hlines(border_down, xmin=0, xmax=2048, color="w", linewidth=1.)[m
[32m++        return self.x_backsubstracted[border_up: border_down, ::][m
[32m++[m
[32m++    def check_fundamental(self):[m
[32m++        sub_array = self.create_sub_array_px_range()[m
[32m++        line_out_y = sub_array[::,1200][m
[32m++        print(line_out_y)[m
[32m++        line_out_y_1 = list(range(0,self.pixel_range))[m
[32m++        print(line_out_y_1)[m
[32m++        self.plot_x_y(line_out_y_1, line_out_y, 'lineout_over_harmonic_y', 'px', 'counts', 4)[m
[32m++        maximum_in_y = np.where(np.amax(sub_array[::, 1200]))[m
[32m++        print('maximum px position: {0} in px-range {1}'.format(maximum_in_y, self.pixel_range))[m
[32m++[m
[32m++    def sum_over_pixel_range(self):[m
[32m++        self.lineout_y = np.sum(self.create_sub_array_px_range(), axis=0)[m
[32m++        return self.lineout_y[m
[32m++[m
[32m++    def set_to_zero_offest(self):[m
[32m++        self.lineout_y[::] = self.lineout_y[::] - np.amin(self.lineout_y[150:1900])[m
[32m++        return self.lineout_y[m
[32m++[m
[32m++    def fit_gaussian(self):[m
[32m++        self.set_to_zero_offest()[m
[32m++        mod = GaussianModel()[m
[32m++        pars = mod.guess(self.lineout_y, x=self.lineout_x)[m
[32m++        out = mod.fit(self.lineout_y, pars, x=self.lineout_x)[m
[32m++        print(out.fit_report(min_correl=0.15))[m
[32m++        self.sigma_temp = out.params['sigma'].value[m
[32m++        self.amplitude_temp = out.params['amplitude'].value[m
[32m++        self.center_temp = out.params['center'].value[m
[32m++        print('sigma: {0} for N:{1} = {2:8.2f}nm'[m
[32m++              .format(self.sigma_temp, self.harmonic_selected, self.lambda_fundamental / self.harmonic_selected))[m
[32m++[m
[32m++        return self.sigma_temp, self.amplitude_temp, self.center_temp[m
[32m++[m
[32m++    def plot_x_y(self, x, y, name, x_label, y_label, plot_number):[m
[32m++        plt.figure(plot_number)[m
[32m++        plt.plot(x, y, label=name)[m
[32m++        plt.xlabel('x_label')[m
[32m++        plt.ylabel('y_label')[m
[32m++        plt.legend()[m
[32m++[m
[32m++    def plot_fit_function(self):[m
[32m++        xx = np.linspace(-self.full_divergence / 2, self.full_divergence, 1000)[m
[32m++        yy = np.zeros([len(xx), 1])[m
[32m++        for x in range(0, len(xx)):[m
[32m++            yy[x] = (self.amplitude_temp / (self.sigma_temp * ((2 * math.pi) ** 0.5))) * math.exp([m
[32m++                (-(xx[x] - self.center_temp) ** 2) / (2 * self.sigma_temp ** 2))[m
[32m++[m
[32m++        self.plot_x_y(self.lineout_x, self.lineout_y, self.filedescription, 'mrad', 'counts', 2)[m
[32m++        self.plot_x_y(xx, yy, 'fit_function', 'mrad', 'counts', 2)[m
[32m++[m
[32m++    def save_linout(self):[m
[32m++        hey = np.stack((self.lineout_x * self.spatial_detector_calibration, self.lineout_y), axis=1)[m
[32m++        np.savetxt(self.filedescription + "lineout" + ".txt", hey, delimiter=' ', fmt='%1.4e')[m
[32m++[m
[32m++[m
[32m++# insert the following ('filepath/picture_name.tif', fundamental frequency (float), ROI_y(px), harmonic number (int), "picture name for plot")[m
[32m++[m
[32m++Picture1 = FWHM_Gaussian_Fit_Processing('rotated/spectro1__Wed Jan 23 2019_14.51.31_17.tif', 805., 60, 23, "20190123_17")[m
[32m++Picture1.open_file()[m
[32m++Picture1.background()[m
[32m++Picture1.check_fundamental()[m
[32m++[m
[32m++Picture1.sum_over_pixel_range()[m
[32m++[m
[32m++Picture1.fit_gaussian()[m
[32m++Picture1.plot_fit_function()[m
[32m++# Picture1.save_data()[m
[32m++[m
[32m++plt.show()[m
[32m++>>>>>>> 2576653b582aff2c784a087d0d5e5d1e10b9c7da[m
